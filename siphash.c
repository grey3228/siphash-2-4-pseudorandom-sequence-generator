#include <stddef.h>
#include <stdint.h>

/* объявление констант, хранищих число раундов сжатия (2) и финализации (4)
 для алгоритма SipHash-2-4 */
#ifndef cROUNDS
#define cROUNDS 2
#endif
#ifndef dROUNDS
#define dROUNDS 4
#endif

// операция побитового циклического сдвига влево
#define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))

/* операция разбиения беззнакового 32-битного числа
 на 4 беззнаковых числа длиной 8 бит */
#define U32TO8_LE(p, v)                                                        \
    (p)[0] = (uint8_t)((v));                                                   \
    (p)[1] = (uint8_t)((v) >> 8);                                              \
    (p)[2] = (uint8_t)((v) >> 16);                                             \
    (p)[3] = (uint8_t)((v) >> 24);

/* операция разбиения беззнакового 64-битного числа
 на 8 беззнаковых чисел длиной 8 бит */
#define U64TO8_LE(p, v)                                                        \
    U32TO8_LE((p), (uint32_t)((v)));                                           \
    U32TO8_LE((p) + 4, (uint32_t)((v) >> 32));

/* операция создания беззнакового 64-битного числа
 из 8 беззнаковых чисел длиной 8 бит */
#define U8TO64_LE(p)                                                           \
    (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) |                        \
     ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) |                 \
     ((uint64_t)((p)[4]) << 32) | ((uint64_t)((p)[5]) << 40) |                 \
     ((uint64_t)((p)[6]) << 48) | ((uint64_t)((p)[7]) << 56))

/* объявление раундовой функции, состоящей из 14 последовательных
 операций */
#define SIPROUND                                                               \
    do {                                                                       \
        v0 += v1;                                                              \
        v1 = ROTL(v1, 13);                                                     \
        v1 ^= v0;                                                              \
        v0 = ROTL(v0, 32);                                                     \
        v2 += v3;                                                              \
        v3 = ROTL(v3, 16);                                                     \
        v3 ^= v2;                                                              \
        v0 += v3;                                                              \
        v3 = ROTL(v3, 21);                                                     \
        v3 ^= v0;                                                              \
        v2 += v1;                                                              \
        v1 = ROTL(v1, 17);                                                     \
        v1 ^= v2;                                                              \
        v2 = ROTL(v2, 32);                                                     \
    } while (0)

/* объявление функции. На вход принимается:
 * in - входное сообщение;
 * inlen - длина входного сообщения;
 * k - ключ длиной 128 бит;
 * out - массив длиной 64 бит для записи хэш-значения.
 * */
int siphash(const void *in, const size_t inlen, const void *k, uint8_t *out) {

    /* преобразование типов массива входного сообщения и ключа
     (от void к unsigned char).
     Это необходимо для дальнейших вычислений */
    const unsigned char *ni = (const unsigned char *)in;
    const unsigned char *kk = (const unsigned char *)k;

    /* объявление 64-битных переменных v0, v1, v2, v3 под хранение
     внутреннего состояния хэш-функции. Данные переменные
     инициализируются константами */
    uint64_t v0 = UINT64_C(0x736f6d6570736575);
    uint64_t v1 = UINT64_C(0x646f72616e646f6d);
    uint64_t v2 = UINT64_C(0x6c7967656e657261);
    uint64_t v3 = UINT64_C(0x7465646279746573);
    /* объявление и инициализация 64-битных переменных k0, k1
     * под хранение 1-ой и 2-ой половин 128 битного ключа */
    uint64_t k0 = U8TO64_LE(kk);
    uint64_t k1 = U8TO64_LE(kk + 8);
    /* объявление переменной под хранение 64-битного блока
     входного сообщения */
    uint64_t m;
    // указатель на последние 8 байт входного сообщения
    const unsigned char *end = ni + inlen - (inlen % sizeof(uint64_t));
    // число байт входного сообщения в последнем 8-байтовом блоке
    const int left = inlen & 7;
    /* 64-битное число, в последних 8 байтах которого
     содержится длина входного сообщения по модулю 256 */
    uint64_t b = ((uint64_t)inlen) << 56;
    /* сложение по модулю 2 слов внутреннего состояния с половинами
     ключа */
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    /* объявление вспомогательного счётчика для организации
     цикла for */
    int i;
    /* цикл, работающий до тех пор, пока не будут перебраны все
    8-байтные блоки входного сообщения, кроме последнего блока */
    for (; ni != end; ni += 8) {
        // сохранение очередного 8-байтного блока сообщения в переменную
        m = U8TO64_LE(ni);
        // обновление 4-го слова внутреннего состояния
        v3 ^= m;
        // "с" итераций раундовой функции
        for (i = 0; i < cROUNDS; ++i)
            SIPROUND;
        // обновление 1-го слова внутреннего состояния
        v0 ^= m;
    }

    /* формирование последнего 8 байтного блока из
    последних от 0 до 7 байтов входного сообщения.
    Стоит заметить, что в последний (восьмой) байт
    последнего блока записывается длина всего
    входного сообщения по модулю 256 */
    switch (left) {
    case 7:
        b |= ((uint64_t)ni[6]) << 48;
    case 6:
        b |= ((uint64_t)ni[5]) << 40;
    case 5:
        b |= ((uint64_t)ni[4]) << 32;
    case 4:
        b |= ((uint64_t)ni[3]) << 24;
    case 3:
        b |= ((uint64_t)ni[2]) << 16;
    case 2:
        b |= ((uint64_t)ni[1]) << 8;
    case 1:
        b |= ((uint64_t)ni[0]);
        break;
    case 0:
        break;
    }

    // обновление 4-го слова внутреннего состояния
    v3 ^= b;
    // "с" итераций раундовой функции
    for (i = 0; i < cROUNDS; ++i)
        SIPROUND;
    // обновление 1-го слова внутреннего состояния
    v0 ^= b;
    // обновление 2-го слова внутреннего состояния
    v2 ^= 0xff;
    // "d" итераций раундовой функции
    for (i = 0; i < dROUNDS; ++i)
        SIPROUND;
    // формирование хэш-значения
    b = v0 ^ v1 ^ v2 ^ v3;
    // запись хэш-значения в выходной массив
    U64TO8_LE(out, b);
    return 0;
}
